
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>Solving the advection-diffusion-reaction equation in Python &mdash; FVM Docs 0.1 documentation</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    
<link rel="stylesheet" href="_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" href="_static/css/bootstrap.min.css" type="text/css" />
<link rel="stylesheet" href="_static/css/font-awesome.min.css">
<!--[if IE 7]>
<link rel="stylesheet" href="_static/css/font-awesome-ie7.min.css">
<![endif]-->
<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
}
</style>
<link rel="stylesheet" href="_static/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="_static/pygments.css" type="text/css" />
<link rel="stylesheet" href="_static/css/bootstrap-responsive.min.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    '',
            VERSION:     '0.1',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
<script type="text/javascript" src="_static/js/jquery.min.js"></script>
<script type="text/javascript" src="_static/underscore.js"></script>
<script type="text/javascript" src="_static/doctools.js"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="_static/js/bootstrap.min.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    $('.show-sidebar').click(function(e) {
       e.preventDefault();
       if ($(".show-sidebar").html() == "Open Table Of Contents") {
          $('.for-mobile').removeClass('hidden-phone');
          $(".show-sidebar").html("Close Table Of Contents");
       } else {
          $(".show-sidebar").html("Open Table Of Contents");
       }
    });
  });
</script>
    <link rel="top" title="FVM Docs 0.1 documentation" href="index.html" />
    <link rel="prev" title="The Poisson equation" href="poisson.html" /> 
  </head>
  <body>
    <div class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="index.html">FVM Docs 0.1 documentation</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right">
              
                <li>
                <a href="genindex.html" title="General Index" accesskey="I">index</a>
                </li>
                <li>
                <a href="poisson.html" title="The Poisson equation" accesskey="P">previous</a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container-fluid">


      
      <div class="row-fluid hidden-desktop hidden-tablet">
      
<div class="span3 ">
  <a class="visible-phone btn btn-small show-sidebar" data-toggle="collapse" data-target=".for-mobile">Open Table Of Contents</a>
  <div class="for-mobile sidebar hidden-phone">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solving the advection-diffusion-reaction equation in Python</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#the-mesh-class">The <tt class="code docutils literal"><span class="pre">Mesh</span></tt> class</a></li>
<li><a class="reference internal" href="#the-cellvariable-class">The <tt class="code docutils literal"><span class="pre">CellVariable</span></tt> class</a></li>
<li><a class="reference internal" href="#the-model-class">The <tt class="code docutils literal"><span class="pre">Model</span></tt> class</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="poisson.html"
                        title="previous chapter">The Poisson equation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/implementation_advection_diffusion.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div>
      </div>
      

      <!-- row -->
      <div class="row-fluid">
         
<div class="span3 visible-desktop visible-tablet">
  <div class=" sidebar hidden-phone">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solving the advection-diffusion-reaction equation in Python</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#the-mesh-class">The <tt class="code docutils literal"><span class="pre">Mesh</span></tt> class</a></li>
<li><a class="reference internal" href="#the-cellvariable-class">The <tt class="code docutils literal"><span class="pre">CellVariable</span></tt> class</a></li>
<li><a class="reference internal" href="#the-model-class">The <tt class="code docutils literal"><span class="pre">Model</span></tt> class</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="poisson.html"
                        title="previous chapter">The Poisson equation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/implementation_advection_diffusion.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        

        <div class="span9">
          <div class="document">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <div class="section" id="solving-the-advection-diffusion-reaction-equation-in-python">
<h1>Solving the advection-diffusion-reaction equation in Python<a class="headerlink" href="#solving-the-advection-diffusion-reaction-equation-in-python" title="Permalink to this headline">¶</a></h1>
<p>Here we discuss how to implement a solver for the advection-diffusion equation in Python. The notes will consider how to design a solver which minimises code complexity and maximise readability.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>At a high-level usage of the code looks like the following,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Define a mesh</span>
<span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="hll"><span class="n">mesh</span> <span class="o">=</span>  <span class="n">Mesh</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
</span>
<span class="c"># Define coefficients</span>
<span class="hll"><span class="n">a</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span> <span class="c"># Advection velocity</span>
</span><span class="hll"><span class="n">d</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span> <span class="c"># Diffusion coefficient</span>
</span>
<span class="c"># Make a &#39;model&#39; and apply boundary conditions</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Time step</span>
<span class="hll"><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class="n">model</span><span class="o">.</span><span class="n">set_boundary_conditions</span><span class="p">(</span><span class="n">left_value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">right_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

<span class="c"># Ask for the discretised system...</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">coefficient_matrix</span><span class="p">()</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">alpha_matrix</span><span class="p">()</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">beta_vector</span><span class="p">()</span>

<span class="c"># Solve...</span>
</pre></div>
</div>
<p>There are a number of classes (highlighted above) which abstract away details of dealing with finite-volume equations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><tt class="code docutils literal"><span class="pre">Mesh</span></tt></li>
<li><tt class="code docutils literal"><span class="pre">CellVariable</span></tt></li>
<li><tt class="code docutils literal"><span class="pre">Model</span></tt></li>
</ol>
</div></blockquote>
<p>The the <tt class="code docutils literal"><span class="pre">Mesh</span></tt> and <tt class="code docutils literal"><span class="pre">CellVariable</span></tt> classes have been inspired by the approach of <a class="reference external" href="http://www.ctcms.nist.gov/fipy/">Fipy</a>.</p>
<p>In the following we will highlight the main features of each class and point out how they are useful. The classes do not attempt at doing &#8220;<em>too much</em>&#8221;, they simply aid in the creation of the linear system.</p>
</div>
<div class="section" id="the-mesh-class">
<h2>The <tt class="code docutils literal"><span class="pre">Mesh</span></tt> class<a class="headerlink" href="#the-mesh-class" title="Permalink to this headline">¶</a></h2>
<p><tt class="code docutils literal"><span class="pre">Mesh</span></tt> objects are initialised with a list of faces locations, which can be non-uniformly distributed if desired. A mesh is completely defined by locations of cell <strong>faces</strong>. Some useful methods,</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p><tt class="code docutils literal"><span class="pre">h()</span></tt> returns the cell width for cell with index <tt class="code docutils literal"><span class="pre">i</span></tt>. This is function is vectorisable by passing an array of the required indices but it <em>does not</em> accept &#8220;fancy indexing&#8221;. The reason being, that it is very easy to make mistakes with subscript indexing, the goal here is to make the user be explicit when requesting elements. Note the <tt class="code docutils literal"><span class="pre">self.cell_widths</span></tt> instance variable returns the numpy array of cell widths is a second way of accessing this data.</p>
<div class="code python highlight-python"><pre>def hm(self, i):
...</pre>
</div>
<p><tt class="code docutils literal"><span class="pre">hm()</span></tt> returns the distance between cell centroids for the cell at index <tt class="code docutils literal"><span class="pre">i</span></tt> and <tt class="code docutils literal"><span class="pre">i-1</span></tt>, that is in the <em>backwards</em> or <strong>minus</strong> direction.</p>
<div class="code python highlight-python"><pre>def hp(self, i):
...</pre>
</div>
<p>Similarly <tt class="code docutils literal"><span class="pre">hp()</span></tt> returns the distance between cell centroids for the cell at index <tt class="code docutils literal"><span class="pre">i</span></tt> and <tt class="code docutils literal"><span class="pre">i+1</span></tt>, that is in the <em>forwards</em> or <strong>plus</strong> direction.</p>
<p>In addition to the above method, the class contains the instance variables, <tt class="code docutils literal"><span class="pre">self.cells</span></tt> which returns an array of cell centroid locations, <tt class="code docutils literal"><span class="pre">self.J</span></tt> which contains the number of cells, and also a copy of the face locations (an array) via <tt class="code docutils literal"><span class="pre">self.faces</span></tt>.</p>
</div>
<div class="section" id="the-cellvariable-class">
<h2>The <tt class="code docutils literal"><span class="pre">CellVariable</span></tt> class<a class="headerlink" href="#the-cellvariable-class" title="Permalink to this headline">¶</a></h2>
<p>The goal of the <tt class="code docutils literal"><span class="pre">CellVariable</span></tt> class is to provide a elegant way of automatically interpolating between the cell value and the face value. The class holes values which correspond to the <strong>cell average</strong>. Internally, this class is a subclass of <tt class="code docutils literal"><span class="pre">numpy.ndarray</span></tt> so it is a fully functioning numpy array. It has a new constructor and additional method which return interpolated values at the cell surfaces.</p>
<p>A <tt class="code docutils literal"><span class="pre">CellVariable</span></tt> is initialised with a value for the cell average (this can be a constant or an array-like quantity) and the <tt class="code docutils literal"><span class="pre">Mesh</span></tt> on which the cell variable is defined. My coupling the cell variable with the mesh the class can perform interpolation between the cell and face values using the methods,</p>
<div class="code python highlight-python"><pre>def p(self, i):
...

def m(self, i)
...</pre>
</div>
<p>Again <tt class="code docutils literal"><span class="pre">self.p(i)</span></tt> stands for the <em>plus</em> direction and <tt class="code docutils literal"><span class="pre">self.m(i)</span></tt> stands for the <em>minus</em> direction, as such they return values at the right and left face of the cell. The mesh can be returned via the instance variable <tt class="code docutils literal"><span class="pre">cell_variable.mesh</span></tt>.</p>
</div>
<div class="section" id="the-model-class">
<h2>The <tt class="code docutils literal"><span class="pre">Model</span></tt> class<a class="headerlink" href="#the-model-class" title="Permalink to this headline">¶</a></h2>
<p>The model class is where the creating of the matrices occurs and where boundary conditions can be applied to the problem. For these reasons the class is fairly complicated.</p>
<p>There are method which return different element of the final matrix. The interior elements are fairly homogenous, the only real difference is where there are spatially varying coefficient of cell widths. For this reason the the method <tt class="code docutils literal"><span class="pre">_interior_matrix_elements()</span></tt> returns elements which correspond to the lower, central and upper diagonals for a specific index. For example, to calculate the interior matrix elements for mesh point at value <tt class="code docutils literal"><span class="pre">index</span></tt> one would do the following,</p>
<div class="code python highlight-python"><pre># Return the the interior matrix elements (the r-terms)
# for a particular spatial index
    model = Model(...)
index = ...
# The lower, central and, upper diagonal terms of the stencil
    ra, rb, rc = model._interior_matrix_elements(index)</pre>
</div>
<p>The function names here correspond to the matrix element in the previous section.</p>
<p>Note that the function is prefixed with an underscore this is because are private, &#8216;users&#8217; should have no need to call these method. It is called internally when constructing the finite-volume matrices. However, as this is a overview of how to implement this is an readable and useful way we include this detail.</p>
<p>The following methods play a similar role,</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_robin_boundary_condition_matrix_elements_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="k">def</span> <span class="nf">_robin_boundary_condition_matrix_elements_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="k">def</span> <span class="nf">_dirichlet_boundary_condition_matrix_elements_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="k">def</span> <span class="nf">_dirichlet_boundary_condition_matrix_elements_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>They return a list of index-value pairs <tt class="code docutils literal"><span class="pre">([(1,1),</span> <span class="pre">a11],</span> <span class="pre">[(i,2),</span> <span class="pre">b12]</span> <span class="pre">...)</span></tt>. The functions return the value of element which need to change (with respect to the interior values) in order include boundary conditions. The index-value pair facilitates automatic insertion of the values into the correct matrix element. As we will see later, rather than hard coding the position of the various element if the index and value are specified it makes the destination of the element unambiguous. It also allows the value of the matrix element to be defined at the same point in the code as the location. This is beneficial for providing context and should reduce bugs and complexity.</p>
<p>The elements for the <span class="math">\(\beta\)</span> boundary condition vector (which is added to the linear system) are generated from the functions below,</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_robin_boundary_condition_vector_elements_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">_robin_boundary_condition_vector_elements_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">_dirichlet_boundary_condition_vector_elements_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">_dirichlet_boundary_condition_vector_elements_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Again, these method should return <em>index-values</em> pairs.</p>
<p>The <tt class="code docutils literal"><span class="pre">Model</span></tt> class also include some convenience function for checking the value of the Peclet number and the CFL conditions which can be called via,</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">peclet_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_widths</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>

<span class="k">def</span> <span class="nf">CFL_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_widths</span>
</pre></div>
</div>
<p>The method which are intended for the user to actually call when constructing the linear system are,</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">coefficient_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">alpha_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">beta_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The linear system for time-stepping can be constructed easily,</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># In pseudo-code</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AdvectionDiffusionModel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">coefficient_matrix</span><span class="p">()</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">alpha_matrix</span><span class="p">()</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">beta_vector</span><span class="p">()</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>

<span class="c"># Apply boundary conditions</span>
<span class="n">u_init</span> <span class="o">=</span> <span class="o">...</span> <span class="c">#</span>
<span class="o">...</span>

<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.01</span>   <span class="c"># time step</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c"># Implicit/explicit parameter</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">u_init</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="c"># time step the linear system, A.x = d</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">I</span> <span class="o">-</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">M</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, when initialising a <tt class="code docutils literal"><span class="pre">Model</span></tt> object the keyword argument <tt class="code docutils literal"><span class="pre">,</span> <span class="pre">discretisation</span></tt> is important. Is can be set to one of the following <tt class="code docutils literal"><span class="pre">'upwind',</span> <span class="pre">'central',</span> <span class="pre">'exponential'</span></tt>. The <tt class="code docutils literal"><span class="pre">upwind</span></tt> option uses the classic <em>first order upwind</em> discretisation, <tt class="code docutils literal"><span class="pre">central</span></tt> uses <em>second-order central</em> and setting to <tt class="code docutils literal"><span class="pre">exponential</span></tt> uses an adaptive scheme which will use weight between the central and upwind scheme depending on the local value of the Peclet number. This is the classic &#8216;exponential fitting&#8217; or &#8216;Scharfetter-Gummel&#8217; discretisation. <strong>N.B.</strong> Scharfetter-Gummel also refers to a method of solving the advection-diffusion equation is a non-coupled manner, this is not the case here where it only refers to the the discretisation method.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>For the following example the analytical solution is plotted as the thin black line and the parameters are,</dt>
<dd><ul class="first last simple">
<li>a = 1</li>
<li>d = 0.001</li>
<li>The domain is between (0,1)</li>
<li>k = 0.01 (time step)</li>
<li>N = 50 (number of cells)</li>
</ul>
</dd>
</dl>
<p>Dirichlet boundary conditions, <span class="math">\(u(0,t)=1\)</span> and <span class="math">\(u(1,t)=0\)</span> and enforced as such should expect a boundary layer to form near <span class="math">\(x=1\)</span>.</p>
<p><strong>Uniform grid</strong></p>
<p>First we test the finite-volume method using a standard uniform grid. Note that the Peclet number for the above parameters is <span class="math">\(\mu=20\)</span> so the central discretisation scheme is not stable as illustrated by the oscillations in the solution. The upwind scheme does not have a stability criteria related to the Peclet number so the solutions for the <em>upwind</em> case are smooth. Finally, the <em>exponentially fitted</em> scheme has automatically weighted in favour of the upwind discretisation, the value of <span class="math">\(\kappa\approx\)</span> 0.9.</p>
<div style="margin-top:10px;">
      <iframe src="http://player.vimeo.com/video/69527955" width="480" height="460" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>
</div><p><strong>Random grid</strong></p>
<p>Although a random grid is of no practical use it is a good test of the code because bugs are more likely to show up when symmetry has been reduced. I the follow simulations <span class="math">\(\text{min}(\kappa)\)</span> =0.004 and <span class="math">\(\text{max}(\kappa)\)</span> =0.98 so the discretisation scheme is abruptly changing from cell to cell.</p>
<div style="margin-top:10px;">
      <iframe src="http://player.vimeo.com/video/69528243" width="480" height="460" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>
</div><p><strong>Nonuniform grid</strong></p>
<p>Nonuniform grids can be used to reduce to <em>improve</em> the solution as shown here. The following simulation contains the same number of cells as the previous simulations however the cell centres are clustered towards the right hand boundary. The increased density of cells allow the boundary layer to be resolved. The transient solution computed from the <em>central</em> scheme is still significantly affected by the high Peclet number but it is interesting to observe that the steady-state solution of all three methods are very similar. Furthermore, <span class="math">\(\kappa\approx0.01-0.1\)</span> in the region of the boundary layer which implies the local value of Peclet number as been reduced enough so allow the exponentially fitted scheme to weight in favour of the higher accuracy central discretisation.</p>
<div style="margin-top:10px;">
      <iframe src="http://player.vimeo.com/video/69528242" width="480" height="460" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>
</div></div>
</div>


                </div>
              </div>
            </div>
          </div>
        </div>
        
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row-fluid">
<div class="related navbar ">
  <div class="navbar-inner">
    <ul class="nav pull-right">
      
        <li><a href="genindex.html" title="General Index" >index</a></li>
        <li><a href="poisson.html" title="The Poisson equation" >previous</a></li>
        <li><a href="index.html">FVM Docs 0.1 documentation</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer>
          &copy; Copyright 2013, Daniel J Farrell.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>